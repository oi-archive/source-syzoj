{"title":"1-01B. 寒域爷的奇怪代码","time_limit":750,"memory_limit":512,"tags":["2019小学期","水题"],"operation":{"submit":"https://oj.xjtuicpc.com/problem/1015#submit_code","submissions":"https://oj.xjtuicpc.com/submissions?problem_id=1015","statistics":"https://oj.xjtuicpc.com/problem/1015/statistics/fastest","testdata":"https://oj.xjtuicpc.com/problem/1015/testdata","discussion":"https://oj.xjtuicpc.com/discussion/problem/1015"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"寒域爷最近突然精神抖擞，写下了大篇代码。刚刚学完时间复杂度的JM试图在一晚上弄懂寒域爷在代码中蕴含的深邃的思想，但是它却难以分析寒域爷的代码。于是愤怒的JM把你抓来了，要你为他讲解寒域爷代码的时间复杂度，如果他听不懂的话就把你喂给寒域爷制造更多的代码。\r\n\r\n### 代码1\r\n该函数出自两年前的ACM小学期课程中，用于实现求从1加到x的和\r\n```C++\r\nint sum(int _Xx) {\r\n\tint ret = 0;\r\n\tfor (int i = 1; i <= _Xx; i++) ret += i;\r\n\treturn ret;\r\n}\r\n```\r\n\r\n### 代码2\r\n代码1被寒域爷魔改后，大大降低了时间复杂度，仍然是用于实现求从1加到x的和\r\n```C++\r\ninline int sum(int _Xx) { return (1 + _Xx) * _Xx / 2; }\r\n```\r\n\r\n### 代码3\r\n这一坨代码出自刚刚接触C语言的小透明寒域，该函数用于将arr数组中的num个元素排序\r\n```C++\r\nvoid bubble_sort(int* arr, int num) {\r\n\tfor (int i = 0; i < num - 1; i++)\r\n\t\tfor (int j = 0; j < num - i - 1; j++)\r\n\t\t\tif (arr[j] < arr[j + 1]) arr[j] ^= arr[j + 1] ^= arr[j] ^= arr[j + 1];\r\n}\r\n```\r\n\r\n### 代码4\r\n在寒域爷偶然间翻看自己以前写的破烂代码的时候，他将代码3修改成了下面的样子。该函数用于将arr数组中的num个元素排序\r\n```C++\r\n#include <queue>\r\nvoid heap_sort(int* arr, int num) {\r\n\tstd::priority_queue<int> heap;\r\n\tfor (int i = 0; i < num; i++) heap.push(arr[i]);\r\n\tfor (int i = 0; i < num; i++) {\r\n\t\tarr[i] = heap.top(); \r\n\t\theap.pop();\r\n\t}\r\n}\r\n```\r\n\r\n### 代码5\r\n这个代码出自寒域爷闲暇时候用来测试Node.js语言和C语言的速度差距。该函数用于求斐波那契数列的第x项\r\n```C++\r\nlong long int fibonacci(int _Xx) {\r\n    if (_Xx <= 2) return 1;\r\n    return fibonacci(_Xx - 1) + fibonacci(_Xx - 2);\r\n}\r\n```\r\n\r\n### 代码6\r\nJM看到寒域的垃圾代码后劈头盖脸训斥了寒域一顿，并修改成了下面的函数。该函数用于求斐波那契数列的第x项($x<1000$)\r\n```C++\r\n#include <cstring>\r\nlong long int fibonacci(int _Xx) {\r\n\tstatic long long int save[1000];\r\n\tstatic bool first = true;\r\n\tif (first) first = false, memset(save, -1, sizeof(save));\r\n\tif (save[_Xx] != -1) return save[_Xx];\r\n\tif (_Xx <= 2) return 1;\r\n\treturn save[_Xx] = fibonacci(_Xx - 1) + fibonacci(_Xx - 2);\r\n}\r\n```\r\n\r\n### 代码7\r\n该函数用于计算最长的每个字母最多出现一次的子字符串的长度，出处已经不可考。\r\n```C++\r\n#include <string>\r\nint lengthOfLongestSubstring(std::string s) {\r\n\tint i, j, len = 0, maxx = 0;\r\n\tbool sign[30];\r\n\tmemset(sign, 0, sizeof(sign));\r\n\tfor (i = 0, j = 0; j < s.length(); ++j) {\r\n\t\twhile (sign[s[j] - 'a'] == 1) {\r\n\t\t\tsign[s[i] - 'a'] = 0;\r\n\t\t\t++i;\r\n\t\t}\r\n\t\tsign[s[j] - 'a'] = 1;\r\n\t\tmaxx = std::max(maxx, j - i + 1);\r\n\t}\r\n\treturn maxx;\r\n}\r\n```"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"没有输入"},{"title":"输出格式","type":"output_format","format":"markdown","require":["katex"],"content":"这是一道提交答案题，你应该把你分析的结果按照下面的格式直接写在提交中。  \r\n\r\n如果满足多个时间复杂度，请选择最早出现的那一个。\r\n\r\n|时间复杂度|你要写的内容|\r\n|-:|:-|\r\n|$O(1)$|1|\r\n|$O(\\log n)$|logn|\r\n|$O(n)$|n|\r\n|$O(n \\log n)$|nlogn|\r\n|$O(n^2)$|n2|\r\n|$O(n^3)$|n3|\r\n|$O(n^4)$|n4|\r\n|$O(2^n)$|2n|\r\n|$O(n!)$|n!|"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"没有样例"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"**Hint**\r\n\r\n注意本题的提交方式和通常的题目不同，仔细看，如你所见，在提交界面左侧有`代码1.usr`，`代码2.usr`，……，`代码7.usr`这7个小节，你需要**在每一小节都填写答案**，填写的内容与题目描述中的7份代码一一对应。\r\n\r\n注意本题答案提交的答案不会被网页暂存在输入框中，多次提交需要多次输入7个小节，建议在本地写好然后往上复制，不然一旦WA了你就得全部重做了。"}]}