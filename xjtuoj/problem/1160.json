{"title":"zxh的业界良心","time_limit":1000,"memory_limit":512,"tags":["2020小学期","动态规划"],"operation":{"submit":"https://oj.xjtuicpc.com/problem/1160#submit_code","submissions":"https://oj.xjtuicpc.com/submissions?problem_id=1160","statistics":"https://oj.xjtuicpc.com/problem/1160/statistics/fastest","testdata":"https://oj.xjtuicpc.com/problem/1160/testdata","discussion":"https://oj.xjtuicpc.com/discussion/problem/1160"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"有一个由正整数组成的三角形，第一行只有一个数，除了最下行之外每个数的左下方和右下方各有一个数，从第一行的数开始，每次可以往左下或右下走一格，直到走到最下行，把沿途经过的数全部加起来，如何才能让这个和**尽量大**。\r\n\r\n等等，这个题目好像有点熟悉？这不就是上课讲的数字三角形问题吗？但这一回，伟大领袖 zxh 还想要你给他指出一条这样的路线，即用一个长度为 $n-1$ 的字符串描述每一步分别应当向左下方走（`L`）还是右下方走（`R`）。如果有多种方案，任意输出一种即可。\r\n\r\n"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"第一个行一个正整数 $n$ ,表示行的数目。\r\n\r\n后面每行为这个数字三角形这一行包含的整数。"},{"title":"输出格式","type":"output_format","format":"markdown","require":["katex"],"content":"第一行一个整数，代表那个可能得到的最大的和。\r\n\r\n第二行描述方案，输出一个长度为 $n-1$ 的 LR 字符串。"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"**样例输入1**\r\n```\r\n5\r\n7\r\n3 8\r\n8 1 1\r\n2 7 4 4\r\n4 5 2 6 5 \r\n```\r\n\r\n**样例输出1**\r\n```\r\n30\r\nLLRL\r\n```\r\n\r\n样例解释：\r\n```\r\n        7 \r\n      3   8 \r\n    8   1   1  \r\n  2   7   4   4 \r\n4   5   2   6   5 \r\n```\r\n\r\n在上面的样例中,从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大，因此输出字符串 LLRL。\r\n\r\n**样例输入2**\r\n```\r\n3\r\n1\r\n1 1\r\n1 1 1\r\n```\r\n**样例输出2**\r\n```\r\n3\r\nLR\r\n```\r\n样例解释：在上面样例中，LL, LR, RL, RR 路径均可达到最大可能的和 3，任意输出一种即可。"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"$1\\leq n\\leq 1000$，三角形中的数是介于 $[1,100]$ 的正整数。\r\n\r\n提示：如何输出方案？可以在每个位置转移 dp 时顺便记录一个 `int` 数组 `fa` 表示它是由左上角转移而来还是右上角转移而来的，然后找到最后一行的最优解的位置，依据数组 `fa` 倒推回到起点。例如可以这样记录: （状态转移请自行补全代码）\r\n\r\n```cpp\r\nfor (int i = 1; i <= n; ++i)\r\n    for (int j = 1; j <= i; ++j) {\r\n        dp[i][j] = ; // 状态转移 请自行补全代码\r\n        fa[i][j] = dp[i - 1][j] == max(dp[i - 1][j], dp[i - 1][j - 1]) ? 0 : -1;\r\n        // fa 是 -1 代表左上角转移而来，fa 是 0 代表右上角转移而来\r\n    }\r\n```\r\n\r\n倒推时，假设找到了 `xp`，`yp` 是最后一行最优解的位置，那么可以类似这样倒推来记录方案：\r\n\r\n```cpp\r\nstring plan;\r\nwhile(xp > 1) { // 如果 xp==1，说明已经回到了初始位置，不需要再倒推了\r\n    plan += fa[xp][yp] ? 'R' : 'L'; // 看看当前位置是怎样由上一层转移来的\r\n    yp += fa[xp][yp], xp--; // 回到上一层的位置\r\n}\r\nreverse(plan.begin(), plan.end()); // 由于是倒推的，所以要翻转字符串得到正着走的路线\r\n\r\n```"}]}