{"title":"1-01B.czq的奇怪代码","time_limit":1000,"memory_limit":512,"tags":["2020小学期","水题"],"operation":{"submit":"https://oj.xjtuicpc.com/problem/1148#submit_code","submissions":"https://oj.xjtuicpc.com/submissions?problem_id=1148","statistics":"https://oj.xjtuicpc.com/problem/1148/statistics/fastest","testdata":"https://oj.xjtuicpc.com/problem/1148/testdata","discussion":"https://oj.xjtuicpc.com/discussion/problem/1148"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"czq最近发现了许多代码，他希望你能够帮他分析一下每个函数的时间复杂度。\r\n\r\n``` cpp\r\n#include <bits/stdc++.h>\r\n#define DB double\r\n#define LL long long\r\n\r\n#define MST(a,b) memset((a),(b),sizeof(a))\r\n#define MRK() cout<<\"Mark\"<<endl;\r\n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\r\n\r\n#define MAXN 210000\r\n#define MAXM 410000\r\n#define MOD 998244353\r\n#define INF 0x3f3f3f3f\r\n#define LLINF 0x3f3f3f3f3f3f3f3f\r\n#define EPS 1e-5\r\n\r\n#define _ 0\r\nusing namespace std;\r\n\r\n//czq很喜欢lowbit函数，这个函数可以计算n二进制下的最低一位1的值 \r\nint lowbit(int n)\r\n{\r\n\treturn n&-n; \r\n}\r\n\r\n//这是最朴素的试除法判断素数 \r\nbool checkprime1(int n)\r\n{\r\n\tfor (int i=2;i<n;i++)\r\n\t\tif (n%i==0)\r\n\t\t\treturn false;\r\n\treturn true; \r\n}\r\n\r\n//试除法的一种改进 \r\nbool checkprime2(int n)\r\n{\r\n\tfor (int i=2;i*i<=n;i++)\r\n\t\tif (n%i==0)\r\n\t\t\treturn false;\r\n\treturn true; \r\n}\r\n\r\n//递归求解调和级数前n项和 \r\ndouble f(int n)\r\n{\r\n\tif (n==0)\r\n\t\treturn 0;\r\n\telse\r\n\t\treturn f(n-1)+1/(double)n;\r\n} \r\n\r\n//统计n二进制下1的个数 \r\nint bitcount(int n)\r\n{\r\n\tint ans=0;\r\n\twhile (n)\r\n\t{\r\n\t\tans+=(n&1);\r\n\t\tn>>=1;\r\n\t}\r\n\treturn ans;\r\n} \r\n\r\n//这个递归函数用于对数组求和 \r\nint getsum(int a[],int l,int r)\r\n{\r\n\tif (l==r)\r\n\t\treturn a[l];\r\n\tint mid=(l+r)>>1;\r\n\treturn getsum(a,l,mid)+getsum(a,mid+1,r);\r\n}\r\n\r\n//排序函数。。。然而为什么有点慢？这里认为sort函数只使用快速排序。 \r\nvoid mysort(int a[],int l,int r)\r\n{\r\n\tif (l==r)\r\n\t\treturn;\r\n\tint mid=(l+r)>>1;\r\n\tmysort(a,l,mid);\r\n\tmysort(a,mid+1,r);\r\n\tsort(a+l,a+r+1);\r\n}\r\n\r\n\r\n//这个代码出自寒域爷闲暇时候用来测试Node.js语言和C语言的速度差距。该函数用于求斐波那契数列的第x项\r\nlong long int fibonacci(int _Xx) {\r\n    if (_Xx <= 2) return 1;\r\n    return fibonacci(_Xx - 1) + fibonacci(_Xx - 2);\r\n}\r\n\r\n \r\nint main()\r\n{\r\n\t\r\n\treturn ~~(0^_^0);\r\n}\r\n```\r\n\r\n你需要编写程序输出答案。具体格式见“输出格式”。"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"没有输入"},{"title":"输出格式","type":"output_format","format":"markdown","require":["katex"],"content":"如果满足多个时间复杂度，请选择最早出现的那一个。\r\n\r\n|时间复杂度|你要写的内容|\r\n|-:|:-|\r\n|$O(1)$|1|\r\n|$O(\\log n)$|logn|\r\n|$O(\\sqrt{n})$|sqrt(n)|\r\n|$O(n)$|n|\r\n|$O(n \\log n)$|nlogn|\r\n|$O(n \\log^2 n)$|nlog2n|\r\n|$O(n^2)$|n2|\r\n|$O(n^3)$|n3|\r\n|$O(n^4)$|n4|\r\n|$O(2^n)$|2n|\r\n|$O(n!)$|n!|\r\n\r\n你可以使用这个模板：\r\n``` cpp\r\n#include <bits/stdc++.h>\r\n#define DB double\r\n#define LL long long\r\n\r\n#define MST(a,b) memset((a),(b),sizeof(a))\r\n#define MRK() cout<<\"Mark\"<<endl;\r\n#define WRT(x) cout<<#x<<\" = \"<<(x)<<endl;\r\n\r\n#define MAXN 210000\r\n#define MAXM 410000\r\n#define MOD 998244353\r\n#define INF 0x3f3f3f3f\r\n#define LLINF 0x3f3f3f3f3f3f3f3f\r\n#define EPS 1e-5\r\n\r\n#define _ 0\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\tprintf(\"\\n\");\r\n\treturn ~~(0^_^0);\r\n}\r\n```"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"``` plain\r\n1\r\nlogn\r\nsqrt(n)\r\nn\r\nnlogn\r\nnlog2n\r\nn2\r\nn3\r\nn4\r\n2n\r\nn!\r\n```"}]}