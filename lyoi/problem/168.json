{"title":"「集训队互测 2015」未来程序 · 改","time_limit":1000,"memory_limit":256,"tags":[],"operation":{"submit":"https://lyoi.cc/problem/168#submit_code","submissions":"https://lyoi.cc/submissions?problem_id=168","statistics":"https://lyoi.cc/problem/168/statistics/fastest","testdata":"https://lyoi.cc/problem/168/testdata","discussion":"https://lyoi.cc/discussion/problem/168"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"在 2111 年，第 128 届全国青少年信息学奥林匹克冬令营前夕，Z 君找到了 2015 年，第 32 届冬令营的题目来练习。\r\n\r\n他打开了第三题「未来程序」这道题目：\r\n\r\n「本题是一道提交答案题，一共 10 个测试点。\r\n\r\n对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。\r\n\r\n遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。」\r\n\r\nZ 君想了一下，决定用 2111 年的计算机来试着运行这个题目，但是问题来了，Z 君已经找不到 96 年前的那次比赛的测试数据了 ……\r\n\r\n没有给出输入数据的提交答案题就不成其「提交答案题」之名，为了解决这个问题，Z 君决定将这个题目改造成传统题。\r\n\r\nZ 君知道 96 年前的计算机的性能比现在差多了，所以这道题的测试数据中，输入数据的规模被设计成很小，从而，做这道题的选手只需要暴力模拟源代码的工作流程就可以通过它。\r\n\r\n现在这道题摆到了你的面前。\r\n\r\n本题是一道传统题，一共有 10 个测试点。\r\n\r\n对于每个测试点，你的程序会得到一段程序的源代码和这段程序的输入。你的程序需要运行这段程序，并输出这段程序的输出。\r\n\r\n### 关于给出的源代码的约定\r\nZ 君是一名 C++ 选手。为了简化这个问题，Z 君在给出的源代码中去掉了 C++ 语言的大量特性。从而这个源代码具有以下特点：\r\n\r\n* 第一行必定为 `#include<iostream>`。\r\n  * 这个库中只会调用到对象 `cin`、`cout`、`endl`、`cin` 的 `>>(int)` 函数和 `cout` 的 `<<(int)` 函数。这两个函数分别用于输入和输出一个整数，返回值分别 `cin` 和 `cout`。\r\n* 第二行必定为 `#include<cstdio>`。\r\n  * 这个库中只会调用到 `putchar` 函数。`putchar(c)` 会输出 ASCII 码为 `c` 的字符，并返回 `c`。\r\n* 第三行必定为 `using namespace std;`。\r\n  * 对象 `cin` 的调用不会通过 `std::cin` 进行，`cout` 和 `endl` 同理。\r\n* `int main()` 没有任何参数。\r\n* 所有的变量都是 `int` 或 `int` 数组（含高维数组）类型。\r\n  * 对象 `cin`、`cout`、`endl` 是例外，注意 `putchar` 的参数也是 `int` 类型的。我们保证在运行时这个参数的值在 $ 0 \\sim 127 $ 中。\r\n  * 在运行时，不会出现数组越界问题。\r\n  * 没有维度的范围为 $ 1 $。也即，不会出现 `int a[1][1][1][1][1];` 这样的情况。\r\n  * 维度的范围直接由十进制常量给出。也即，不会出现 `int a[(100 + 100) * 2];` 这样的情况。\r\n* 所有的函数都是 `int` 类型，函数的参数只可能是 `int` 类型。\r\n  * 注意函数的返回值可以被丢弃。\r\n  * 当没有显式地返回值时，返回 $ 0 $。\r\n* `bool` 型被认为是一种特殊的 `int` 型。\r\n  * `==` 在两个参数相同时返回 $ 1 $，否则返回 $ 0 $。\r\n  * `!=` 在两个参数相同时返回 $ 0 $，否则返回 $ 1 $。\r\n  * `<` 在第一个参数小于第二个参数时返回 $ 1 $，否则返回 $ 0 $。\r\n  * `<=` 在第一个参数小于等于第二个参数时返回 $ 1 $，否则返回 $ 0 $。\r\n  * `>` 在第一个参数大于第二个参数时返回 $ 1 $，否则返回 $ 0 $。\r\n  * `>=` 在第一个参数大于等于第二个参数时返回 $ 1 $，否则返回 $ 0 $。\r\n  * `&&` 在两个参数都不为 $ 0 $ 时返回 $ 1 $，否则返回0。\r\n  * `||` 在两个参数都为 $ 0 $ 时返回 $ 0 $，否则返回 $ 1 $。\r\n  * `^` 在两个参数中只有一个为 $ 0 $ 时返回 $ 1 $，其他时候返回 $ 0 $。\r\n  * `!` 在参数为 $ 0 $ 时返回 $ 1 $，否则返回 $ 0 $。\r\n  * 由于 `bool` 型被 `int` 型取代了，因此所有的表达式都应该被完全计算：例如在表达式 `(a && (b = c))` 中，即使 `a` 已经被确定是 $ 0 $，仍然需要计算 `(b = c)` 的值，尽管无论 `(b = c)` 的值如何，整个表达式的值都是 $ 0 $。\r\n* 可能用到的运算符及其优先级如下：（从高到低排列）\r\n  1. `()`、`[]`\r\n  2. `!`、`+`（正号）、`-`（负号）\r\n  3. `*`、`/`、`%`\r\n  4. `+`（加法）、`-`（减法）\r\n  5. `<=`、`>=`、`<`、`>`\r\n  6. `==`、`!=`\r\n  7. `^`\r\n  8. `&&`\r\n  9. `||`\r\n  10. `=`\r\n  11. `cout` 的 `<<` 与 `cin` 的 `>>`。\r\n* 所有 `int` 常量以十进制形式给出。\r\n* Z 君没有对源代码进行混淆，所以源代码是可读的，你不必担心出现大量嵌套的花括号或此类的「垃圾代码」。\r\n* 运行时使用的变量占用的空间的峰值不超过 $ 8 \\texttt{MB} $。也即，$ 2 ^ {21} $ 个 `int`。\r\n* 调用函数的深度不会超过 $ 10 ^ 3 $ 层。\r\n* 可能出现连续赋值，例如 `a = (b = (c = 3) + 2) % c`。\r\n  * 之前对 `c` 的赋值将会反映到之后对 `c` 的引用上。\r\n  * `=` 是右结合的，`a = b = c` 会被看作 `a = (b = c)`。\r\n  * 赋值的返回值为赋值以后的值。\r\n* 可能出现的程序流程控制语句：\r\n  * `if (statement) statement [else statement]`\r\n  * `while (statement) statement`\r\n  * `for ([statement]; [statement]; [statement]) statement`\r\n  * 那些作为条件的 `statement` 的返回值应当被视为 `bool` 型的。具体的来说，若返回值为 $ 0 $，则为 `false`，若返回值非 $ 0 $，则为 `true`。在 `for` 循环中，当第二个 `[statement]` 取空时，视为 `true`。\r\n* 空白字符只有新行符（即 `\\n`）和空格。\r\n* 声明变量时默认初始值为 `0`，声明变量的同时不会进行赋值。\r\n* 没有注释。\r\n* 所有的右花括号后没有分号。\r\n* 没有用来连接语句的逗号。\r\n* 没有函数和变量重名。"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"输入文件分为两个部分。\r\n\r\n第一行，有一个整数 `N`。它描述了源代码对应的输入文件 `program.in` 中包含的整数数目。\r\n\r\n以下 `N` 个整数构成了源代码对应的输入文件 `program.in`。\r\n\r\n这之后的部分构成了源代码 `program.cpp`。"},{"title":"输出格式","type":"output_format","format":"markdown","require":["katex"],"content":"输出文件是将 `program.cpp` 编译后输入 `program.in` 后所得到的输出。"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"#### 样例输入 1\r\n```cpp\r\n2\r\n1 2\r\n#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\nint main()\r\n{int a, b; cin >> a >> b; cout << a + b << endl;}\r\n```\r\n\r\n#### 样例输出 1\r\n```plain\r\n3\r\n```\r\n\r\n#### 样例输入 2\r\n```cpp\r\n10\r\n9\r\n6 1 7 5 1 7 2 2 4\r\n#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\nint n, a[100];\r\n\r\n\r\nint main()\r\n{\r\n    cin >> n;\r\n    int i, j, this_VARIABLE_is_NOT_used;\r\n    for (i = 1; i <= n; i = i + 1) cin >> a[i];\r\n    for (i = 1; i <= n; i = i + 1)\r\n    for (j = i + 1; j <= n; j = j + 1)\r\n    if (a[i] > a[j])\r\n    {\r\n        int t;\r\n        t = a[i];\r\n        a[i] = a[j];\r\n        a[j] = t;\r\n    }\r\n    for (i = 1; i <= n; i = i + 1)\r\n    {\r\n        cout << a[i];\r\n        if (i == n) cout << endl; else putchar(32);\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 样例输出 2\r\n```plain\r\n1 1 2 2 4 5 6 7 7\r\n```"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"输入的所有 `program.cpp` 都是手打的，每个输入文件的大小不超过 $ 7 \\texttt{KB} $。\r\n\r\n测试点 `#1` 的 `program.cpp` 为：\r\n\r\n```cpp\r\n#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\n\r\nint this_is_a_solution_to_the_A_plus_B_problem_set_by_vfleaking;\r\n\r\nint INF;\r\n\r\nint N, A[110], B[110], W[110], L[110], R[110], P[110];\r\nint As[110];\r\n\r\nint As_QS(int i, int j)\r\n{\r\n  int l, r, x;\r\n  l = i; r = j;\r\n  x = As[(i + j) / 2];\r\n  while (i <= j)\r\n    {\r\n      while (As[i] < x) i = i + 1;\r\n      while (As[j] > x) j = j - 1;\r\n      if (i <= j)\r\n        {\r\n          int t;\r\n          t = As[i];\r\n          As[i] = As[j];\r\n          As[j] = t;\r\n          i = i + 1;\r\n          j = j - 1;\r\n        }\r\n    }\r\n  if (i < r) As_QS(i, r);\r\n  if (l < j) As_QS(l, j);\r\n  return 0;\r\n}\r\n\r\nint As_lower_bound(int x)\r\n{\r\n  int l, r;\r\n  l = 1; r = N + 1;\r\n  while (l != r)\r\n    {\r\n      int mid;\r\n      if (As[mid = (l + r) / 2] >= x)\r\n        r = mid;\r\n      else\r\n        l = mid + 1;\r\n    }\r\n  return l;\r\n}\r\n\r\nint here_comes_the_SEGMENT_TREE;\r\nint sc, sroot[110], s[1500][2], inS[110], prev[1500];\r\n\r\nint emp(int l, int r)\r\n{\r\n  int cur;\r\n  cur = sc = sc + 1;\r\n  if (l != r)\r\n    {\r\n      int mid;\r\n      mid = (l + r) / 2;\r\n      s[cur][0] = emp(l, mid);\r\n      s[cur][1] = emp(mid + 1, r);\r\n    }\r\n  return cur;\r\n}\r\n\r\nint insert(int cur, int l, int r, int b, int c)\r\n{\r\n  int nx;\r\n  nx = sc = sc + 1;\r\n  prev[nx] = cur;\r\n  s[nx][0] = s[cur][0];\r\n  s[nx][1] = s[cur][1];\r\n  if (l == r)\r\n    inS[c] = nx;\r\n  else\r\n    {\r\n      int mid;\r\n      mid = (l + r) / 2;\r\n      if (b <= mid)\r\n        s[nx][0] = insert(s[nx][0], l, mid, b, c);\r\n      else\r\n        s[nx][1] = insert(s[nx][1], mid + 1, r, b, c);\r\n    }\r\n  return nx;\r\n}\r\n\r\nint here_comes_the_GRAPH_and_the_NETWORK_FLOW;\r\n\r\nint source()\r\n{\r\n  return 1;\r\n}\r\n\r\nint sink()\r\n{\r\n  return 2;\r\n}\r\n\r\nint point_lv_1(int x)\r\n{\r\n  return 2 + x;\r\n}\r\n\r\nint point_lv_2(int x)\r\n{\r\n  return 2 + N + x;\r\n}\r\n\r\nint segnode(int x)\r\n{\r\n  return 2 + (N * 2) + x;\r\n}\r\n\r\nint e[6000], cp[6000], enxt[6000], head[1500], ec, nc;\r\n\r\nint partner(int x)\r\n{\r\n  if (x % 2 == 1)\r\n    return x + 1;\r\n  else\r\n    return x - 1;\r\n}\r\n\r\nint regi(int u, int v, int w)\r\n{\r\n  ec = ec + 1;\r\n  e[ec] = v; cp[ec] = w;\r\n  enxt[ec] = head[u]; head[u] = ec;\r\n}\r\n\r\nint directed(int u, int v, int w)\r\n{\r\n  regi(u, v, w);\r\n  regi(v, u, 0);\r\n}\r\n\r\nint ANS;\r\n\r\nint travel(int cur, int L, int R, int l, int r, int x)\r\n{\r\n  if ((L == l) && (R == r))\r\n    {\r\n      directed(point_lv_2(x), segnode(cur), INF);\r\n      return 0;\r\n    }\r\n  int Mid; Mid = (L + R) / 2;\r\n  if (r <= Mid)\r\n    {\r\n      travel(s[cur][0], L, Mid, l, r, x);\r\n      return 0;\r\n    }\r\n  if (l > Mid)\r\n    {\r\n      travel(s[cur][1], Mid + 1, R, l, r, x);\r\n      return 0;\r\n    }\r\n  travel(s[cur][0], L, Mid, l, Mid, x);\r\n  travel(s[cur][1], Mid + 1, R, Mid + 1, r, x);\r\n}\r\n\r\nint pushflow(int E, int F)\r\n{\r\n  cp[E] = cp[E] - F;\r\n  cp[partner(E)] = cp[partner(E)] + F;\r\n}\r\n\r\nint Nid, tag[1500], lyr[1500], cur[1500], pre[1500], prn[1500], supp[1500], comp[1500], Aug, Gap;\r\n\r\nint relabel(int x)\r\n{\r\n  int ol, nl, E;\r\n  ol = tag[x]; nl = nc;\r\n  for (E = head[x]; E; E = enxt[E])\r\n    if ((cp[E]) && (tag[x] <= tag[e[E]] + 1))\r\n      if (nl > tag[e[E]] + 1)\r\n        nl = tag[e[E]] + 1;\r\n  lyr[nl] = lyr[nl] + 1;\r\n  lyr[ol] = lyr[ol] - 1;\r\n  tag[x] = nl;\r\n  if (lyr[ol] == 0) Gap = 1;\r\n  cur[x] = head[x];\r\n}\r\n\r\nint sap_initialize()\r\n{\r\n  int i;\r\n  for (i = 1; i <= nc; i = i + 1)\r\n    {\r\n      tag[i] = lyr[i] = 0;\r\n      cur[i] = head[i];\r\n    }\r\n  lyr[0] = nc;\r\n  Nid = source();\r\n  Gap = 0;\r\n  supp[Nid] = INF;\r\n  comp[Nid] = 0;\r\n}\r\n\r\nint sap()\r\n{\r\n  int ans; ans = 0;\r\n  while ((tag[source()] != nc) && (Gap == 0))\r\n    {\r\n      if (Nid == sink())\r\n        {\r\n          int increment;\r\n          increment = supp[Nid] - comp[Nid];\r\n          ans = ans + increment;\r\n          int x;\r\n          for (x = sink(); x != source(); x = prn[x])\r\n            {\r\n              comp[x] = comp[x] + increment;\r\n              pushflow(pre[x], increment);\r\n            }\r\n        }\r\n      Aug = 0;\r\n      if (supp[Nid] > comp[Nid])\r\n        for (; (cur[Nid] != 0) && (Aug == 0); cur[Nid] = enxt[cur[Nid]])\r\n          {\r\n            int E;\r\n            E = cur[Nid];\r\n            if ((cp[E]) && (tag[Nid] == tag[e[E]] + 1))\r\n              {\r\n                Aug = 1;\r\n                if (cp[E] < supp[Nid] - comp[Nid])\r\n                  supp[e[E]] = cp[E];\r\n                else\r\n                  supp[e[E]] = supp[Nid] - comp[Nid];\r\n                comp[e[E]] = 0;\r\n                prn[e[E]] = Nid;\r\n                pre[e[E]] = E;\r\n                Nid = e[E];\r\n              }\r\n          }\r\n      if (Aug == 0)\r\n        {\r\n          if (Nid != sink()) relabel(Nid);\r\n          if (Nid == source())\r\n            comp[Nid] = 0;\r\n          else\r\n            Nid = prn[Nid];\r\n        }\r\n      else\r\n        cur[Nid] = head[Nid];\r\n    }\r\n  return ans;\r\n}\r\n\r\nint main()\r\n{\r\n  INF = 1000000000;\r\n\r\n  cin >> N;\r\n  int i;\r\n  for (i = 1; i <= N; i = i + 1)\r\n    cin >> A[i] >> B[i] >> W[i] >> L[i] >> R[i] >> P[i];\r\n  ANS = 0;\r\n  for (i = 1; i <= N; i = i + 1)\r\n    ANS = ANS + B[i] + W[i];\r\n  for (i = 1; i <= N; i = i + 1)\r\n    As[i] = A[i];\r\n  As_QS(1, N);\r\n  sc = 0;\r\n  sroot[0] = emp(1, N);\r\n  for (i = 1; i <= N; i = i + 1)\r\n    sroot[i] = insert(sroot[i - 1], 1, N, As_lower_bound(A[i]), i);\r\n  nc = segnode(sc);\r\n  for (i = 1; i <= nc; i = i + 1)\r\n    head[i] = 0;\r\n  ec = 0;\r\n  for (i = 1; i <= N; i = i + 1)\r\n    {\r\n      directed(source(), point_lv_1(i), B[i]);\r\n      directed(point_lv_1(i), sink(), W[i]);\r\n      directed(point_lv_1(i), point_lv_2(i), P[i]);\r\n    }\r\n  for (i = 1; i <= sc; i = i + 1)\r\n    {\r\n      if ((s[i][0] != 0) && (prev[i]))\r\n        directed(segnode(i), segnode(prev[i]), INF);\r\n      if (s[i][0]) directed(segnode(i), segnode(s[i][0]), INF);\r\n      if (s[i][1]) directed(segnode(i), segnode(s[i][1]), INF);\r\n    }\r\n  for (i = 1; i <= N; i = i + 1)\r\n    directed(segnode(inS[i]), point_lv_1(i), INF);\r\n  for (i = 1; i <= N; i = i + 1)\r\n    {\r\n      int l, r;\r\n      l = As_lower_bound(L[i]);\r\n      r = As_lower_bound(R[i] + 1);\r\n      if (l < r)\r\n        travel(sroot[i - 1], 1, N, l, r - 1, i);\r\n    }\r\n  sap_initialize();\r\n  ANS = ANS - sap();\r\n  cout << ANS << endl;\r\n  return 0;\r\n}\r\n\r\nint orzvfk;\r\nint mo_bai_lv_kai_feng;\r\n```\r\n\r\n测试点 `#2` 到 `#4` 的 `program.cpp` 符合以下格式：\r\n\r\n```cpp\r\n#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\nint main()\r\n{\r\n    cout << <1> << endl;\r\n}\r\n```\r\n\r\n在 `#2` 中：`<1>` 处是一个仅包含加、减、乘、除、模运算和自然数常数的没有括号的表达式。\r\n\r\n在 `#3` 和 `#4` 中：`<1>` 处是一个不保证以上性质的表达式。\r\n\r\n测试点 `#5` 中：没有除 `main` 以外的函数，并且整个程序中只有顺序结构。\r\n\r\n测试点 `#6` 和 `#7` 中：没有除 `main` 以外的函数。\r\n\r\n测试点 `#8` 中：所有的变量都是全局变量。\r\n\r\n测试点 `#9` 和 `#10` 不保证任何特别的性质。\r\n\r\n所有 `program.cpp` 都可以用 MinGW GCC 4.7.2 编译运行。这就是说，所有的 `program.cpp` 中都没有语法错误。然而由于编译命令的不同，直接编译得到的 `program.exe` 在运行时有可能会因未为声明的变量和未设置返回值的函数设置 $ 0 $ 的缺省值以及 `bool` 类型的处理方式不同而与标程产生不同的输出。\r\n\r\n为了更准确地说明程序可能出现的要素，也作为提示，下面给出了一个上下文无关文法，其初始符号为 `PROGRAM`。保证每个 `program.cpp` 都可被下面的文法生成，但是并非每个可被生成的程序都是合法的程序。\r\n\r\n<pre>\r\n<strong>PROGRAM</strong> ::= # include &lt; iostream > # include &lt; cstdio > using namespace std ; <strong>FUNC_AND_VAR</strong>\r\n\r\n<strong>FUNC_AND_VAR</strong> ::=\r\n| ε\r\n| int <strong>NAME</strong> ( <strong>OPTPARAMS</strong> ) { <strong>STATEMENTS</strong> } <strong>FUNC_AND_VAR</strong>\r\n| int <strong>DEFINEVAR</strong> <strong>DEFINEVARS</strong> ; <strong>FUNC_AND_VAR</strong>\r\n\r\n<strong>OPTPARAMS</strong> ::=\r\n| ε\r\n| int <strong>NAME</strong> <strong>PARAMS</strong>\r\n\r\n<strong>PARAMS</strong> ::=\r\n| ε\r\n| , int <strong>NAME</strong> <strong>PARAMS</strong>\r\n\r\n<strong>STATEMENTS</strong> ::=\r\n| ε\r\n| <strong>STATEMENT</strong> <strong>STATEMENTS</strong>\r\n\r\n<strong>STATEMENT</strong> ::=\r\n| <strong>EXPRESSION</strong> ;\r\n| { <strong>STATEMENTS</strong> }\r\n| int <strong>DEFINEVAR</strong> <strong>DEFINEVARS</strong> ;\r\n| if ( <strong>EXPRESSION</strong> ) <strong>STATEMENT</strong>\r\n| if ( <strong>EXPRESSION</strong> ) <strong>STATEMENT</strong> else <strong>STATEMENT</strong>\r\n| for ( <strong>STATEMENT_IN_FOR</strong> ; <strong>OPTEXPRESSION</strong> ; <strong>STATEMENT_IN_FOR</strong> ) <strong>STATEMENT</strong>\r\n| while ( <strong>EXPRESSION</strong> ) <strong>STATEMENT</strong>\r\n| return <strong>EXPRESSION</strong> ;\r\n\r\n<strong>STATEMENT_IN_FOR</strong> ::=\r\n| <strong>EXPRESSION</strong>\r\n| int <strong>DEFINEVAR</strong> <strong>DEFINEVARS</strong>\r\n\r\n<strong>OPTEXPRESSION</strong> ::=\r\n| ε\r\n| <strong>EXPRESSION</strong>\r\n\r\n<strong>EXPRESSION</strong> ::=\r\n| <strong>UNIT9</strong>\r\n| <strong>EXPRESSION</strong> &lt;&lt; <strong>UNIT9</strong>\r\n| <strong>EXPRESSION</strong> >> <strong>UNIT9</strong>\r\n\r\n<strong>UNIT0</strong> ::=\r\n| <strong>INT_CONSTANT</strong>\r\n| <strong>UNIT0</strong> [ <strong>EXPRESSION</strong> ]\r\n| ( <strong>EXPRESSION</strong> )\r\n| <strong>NAME</strong> ( <strong>OPTARGUS</strong> )    // 注：此处的 <strong>NAME</strong> 是一个函数名\r\n| <strong>NAME</strong>    // 注：此处的 <strong>NAME</strong> 是一个变量名\r\n| cin\r\n| cout\r\n| endl\r\n\r\n<strong>UNIT1</strong> ::=\r\n| <strong>UNIT0</strong>\r\n| + <strong>UNIT1</strong>\r\n| - <strong>UNIT1</strong>\r\n| ! <strong>UNIT1</strong>\r\n\r\n<strong>UNIT2</strong> ::=\r\n| <strong>UNIT1</strong>\r\n| <strong>UNIT2</strong> * <strong>UNIT1</strong>\r\n| <strong>UNIT2</strong> / <strong>UNIT1</strong>\r\n| <strong>UNIT2</strong> % <strong>UNIT1</strong>\r\n\r\n<strong>UNIT3</strong> ::=\r\n| <strong>UNIT2</strong>\r\n| <strong>UNIT3</strong> + <strong>UNIT2</strong>\r\n| <strong>UNIT3</strong> - <strong>UNIT2</strong>\r\n\r\n<strong>UNIT4</strong> ::=\r\n| <strong>UNIT3</strong>\r\n| <strong>UNIT4</strong> &lt; <strong>UNIT3</strong>\r\n| <strong>UNIT4</strong> &lt;= <strong>UNIT3</strong>\r\n| <strong>UNIT4</strong> > <strong>UNIT3</strong>\r\n| <strong>UNIT4</strong> >= <strong>UNIT3</strong>\r\n\r\n<strong>UNIT5</strong> ::=\r\n| <strong>UNIT4</strong>\r\n| <strong>UNIT5</strong> == <strong>UNIT4</strong>\r\n| <strong>UNIT5</strong> != <strong>UNIT4</strong>\r\n\r\n<strong>UNIT6</strong> ::=\r\n| <strong>UNIT5</strong>\r\n| <strong>UNIT6</strong> ^ <strong>UNIT5</strong>\r\n\r\n<strong>UNIT7</strong> ::=\r\n| <strong>UNIT6</strong>\r\n| <strong>UNIT7</strong> &amp;&amp; <strong>UNIT6</strong>\r\n\r\n<strong>UNIT8</strong> ::=\r\n| <strong>UNIT7</strong>\r\n| <strong>UNIT8</strong> || <strong>UNIT7</strong>\r\n\r\n<strong>UNIT9</strong> ::=\r\n| <strong>UNIT8</strong>\r\n| <strong>UNIT8</strong> = <strong>UNIT9</strong>\r\n\r\n<strong>OPTARGUS</strong> ::=\r\n| ε\r\n| <strong>EXPRESSION</strong> <strong>ARGUS</strong>\r\n\r\n<strong>ARGUS</strong> ::=\r\n| ε\r\n| , <strong>EXPRESSION</strong> <strong>ARGUS</strong>\r\n\r\n<strong>DEFINEVARS</strong> ::=\r\n| ε\r\n| , <strong>DEFINEVAR</strong> <strong>DEFINEVARS</strong>\r\n\r\n<strong>DEFINEVAR</strong> ::=\r\n| <strong>NAME</strong>\r\n| <strong>DEFINEVAR</strong> [ <strong>INT_CONSTANT</strong> ]\r\n\r\n<strong>NAME</strong> ::= 仅包含大小写字母、数字、下划线的非空字符串，且不以数字开头。\r\n\r\n<strong>INT_CONSTANT</strong> ::= 仅包含数字的非空字符串，且不以 0 开头，或这个字符串就是 0。\r\n</pre>"}]}